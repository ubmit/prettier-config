/**
 * Acts like calling Array.prototype.forEach in that all elements are executed upon in order, and
 * each execution is blocking. Meaning, the callback won't be called on element 2 until the callback
 * has finished its call on element 1.
 */
export declare function awaitedForEach<OriginalGeneric>(input: ReadonlyArray<OriginalGeneric>, callback: (arrayElement: OriginalGeneric, index: number, wholeArray: ReadonlyArray<OriginalGeneric>) => void | PromiseLike<void>): Promise<void>;
export declare function awaitedBlockingMap<OriginalGeneric, MappedGeneric>(input: ReadonlyArray<OriginalGeneric>, callback: (arrayElement: OriginalGeneric, index: number, wholeArray: ReadonlyArray<OriginalGeneric>) => MappedGeneric | PromiseLike<MappedGeneric>): Promise<Awaited<MappedGeneric>[]>;
export declare function awaitedFilter<OriginalGeneric>(arrayInput: ReadonlyArray<OriginalGeneric>, filterCallback: (arrayElement: OriginalGeneric, index: number, wholeArray: ReadonlyArray<OriginalGeneric>) => Promise<unknown>, options?: {
    /**
     * Each call to the filter callback is blocking, meaning the next one won't start until the
     * current one finishes. By default this is false.
     */
    blocking?: boolean | undefined;
}): Promise<OriginalGeneric[]>;
//# sourceMappingURL=async.d.ts.map