import { ansiRegex } from './ansi';
import { deDupeRegExFlags } from './regexp';
/**
 * Join elements into a string with commas separating each value. Add a conjunction before the final
 * item in the list. If the array has a length < 2, the conjunction is not added. If the list is
 * only of length 2, then no commas are added.
 *
 * @param list Array of items to be converted into strings. Works best if these are simply strings
 *   to begin with.
 * @param conjunction Defaults to 'and'. The conjunction to be used before the final element.
 */
export function joinWithFinalConjunction(list, conjunction = 'and') {
    if (list.length < 2) {
        /**
         * If there are not multiple things in the list to join, just turn the list into a string
         * for an empty list, this will be '', for a single item list, this will just be the first
         * item as a string.
         */
        return list.join('');
    }
    /** When there are only two items in the list, we don't want any commas. */
    const commaSep = list.length > 2 ? ', ' : ' ';
    const commaJoined = list.slice(0, -1).join(commaSep);
    const fullyJoined = `${commaJoined}${commaSep}${conjunction} ${list[list.length - 1]}`;
    return fullyJoined;
}
export function removeAnsiEscapeCodes(input) {
    return input.replace(ansiRegex, '');
}
export const removeColor = removeAnsiEscapeCodes;
export function removeCommasFromNumberString(numberString) {
    return numberString.replace(/,/g, '');
}
/** Collapse all consecutive white space into just one space and trim surrounding whitespace. */
export function collapseWhiteSpace(input) {
    return (input
        // sometimes \n isn't included in \s
        .replace(/\n/g, ' ')
        .trim()
        .replace(/\s{2,}/g, ' '));
}
/** Same as String.prototype.split but includes the delimiter to split by in the output array. */
export function splitIncludeSplit(original, splitterInput, caseSensitive) {
    const indexLengths = getAllIndexesOf({
        searchIn: original,
        searchFor: splitterInput,
        caseSensitive,
        includeLength: true,
    });
    const splitter = makeCaseInsensitiveRegExp(splitterInput, caseSensitive);
    const splits = original.split(splitter);
    const splitterIncluded = splits.reduce((accum, current, index) => {
        // this will be undefined on the last index
        const splitterLength = indexLengths[index];
        const includeCurrent = accum.concat(current);
        if (splitterLength) {
            const splitterMatch = original.slice(splitterLength.index, splitterLength.index + splitterLength.length);
            return includeCurrent.concat(splitterMatch);
        }
        else {
            return includeCurrent;
        }
    }, []);
    return splitterIncluded;
}
const defaultCasingOptions = {
    capitalizeFirstLetter: false,
};
export function capitalizeFirstLetter(input) {
    if (!input.length) {
        return '';
    }
    const firstLetter = input[0];
    return (firstLetter.toUpperCase() + input.slice(1));
}
function maybeCapitalize(input, casingOptions) {
    return casingOptions.capitalizeFirstLetter ? capitalizeFirstLetter(input) : input;
}
export function kebabCaseToCamelCase(rawKebabCase, casingOptions = defaultCasingOptions) {
    const kebabCase = rawKebabCase.toLowerCase();
    if (!kebabCase.length) {
        return '';
    }
    const camelCase = kebabCase
        .replace(/^-+/, '')
        .replace(/-{2,}/g, '-')
        .replace(/-(?:.|$)/g, (dashMatch) => {
        const letter = dashMatch[1];
        if (letter) {
            return letter.toUpperCase();
        }
        else {
            return '';
        }
    });
    return maybeCapitalize(camelCase, casingOptions);
}
function isLowerCase(input) {
    // this excludes letters that are identical between lower and upper case like punctuation
    return input !== input.toUpperCase();
}
export function camelCaseToKebabCase(rawCamelCase) {
    const kebabCase = rawCamelCase
        .split('')
        .reduce((accum, currentLetter, index, originalString) => {
        const previousLetter = index > 0 ? originalString[index - 1] : '';
        const nextLetter = index < originalString.length - 1 ? originalString[index + 1] : '';
        const possibleWordBoundary = isLowerCase(previousLetter) || isLowerCase(nextLetter);
        if (currentLetter === currentLetter.toLowerCase() ||
            index === 0 ||
            !possibleWordBoundary) {
            accum += currentLetter;
        }
        else {
            accum += `-${currentLetter.toLowerCase()}`;
        }
        return accum;
    }, '')
        .toLowerCase();
    return kebabCase;
}
export function replaceStringAtIndex(originalString, start, newString, length = newString.length) {
    const before = originalString.substring(0, start);
    const after = originalString.substring(start + length);
    return `${before}${newString}${after}`;
}
/**
 * Escapes characters from the given string so that it can be used within a RegExp without being
 * parsed as RegExp syntax.
 */
export function escapeStringForRegExp(input) {
    return input.replace(/[\^$\\.*+?()[\]{}|]/g, '\\$&');
}
function makeCaseInsensitiveRegExp(searchForInput, caseSensitive) {
    const regExpFlags = `g${!caseSensitive && typeof searchForInput === 'string' ? 'i' : ''}`;
    const searchFor = searchForInput instanceof RegExp
        ? new RegExp(searchForInput.source, deDupeRegExFlags(`${searchForInput.flags}${regExpFlags}`))
        : new RegExp(escapeStringForRegExp(searchForInput), regExpFlags);
    return searchFor;
}
export function getAllIndexesOf({ searchIn, searchFor, caseSensitive, includeLength, }) {
    const searchRegExp = makeCaseInsensitiveRegExp(searchFor, caseSensitive);
    const indexes = [];
    const indexesAndLengths = [];
    searchIn.replace(searchRegExp, (...matchResults) => {
        /**
         * Grabbing the second to last entry in the array (rather than the second) takes capture
         * groups into account.
         */
        const matchIndex = matchResults[matchResults.length - 2];
        // this is used as a type safety catch and cannot actually be triggered on purpose
        // istanbul ignore next
        if (typeof matchIndex !== 'number') {
            throw new Error(`Match index "${matchIndex}" is not a number. Searching for "${searchFor}" in "${searchIn}".`);
        }
        const regExpMatch = matchResults[0];
        // this is used as a type safety catch and cannot actually be triggered on purpose
        // istanbul ignore next
        if (typeof regExpMatch !== 'string') {
            throw new Error(`regExpMatch should've been a string but was ${typeof regExpMatch}!`);
        }
        indexesAndLengths.push({ index: matchIndex, length: regExpMatch.length });
        indexes.push(matchIndex);
        const originalMatch = matchResults[0];
        // this is used as a type safety catch and cannot actually be triggered on purpose
        // istanbul ignore next
        if (typeof originalMatch !== 'string') {
            throw new Error(`Original match when searching for "${searchFor}" in "${searchIn}" at index ${matchIndex} is not a string.`);
        }
        /**
         * Don't actually change any text. What we do here doesn't matter because we're not
         * using the output of the .replace method, we're just producing side effects.
         */
        return originalMatch;
    });
    return (includeLength ? indexesAndLengths : indexes);
}
export function typedSplit(input, splitString) {
    return input.split(splitString);
}
