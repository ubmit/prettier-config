export declare function wait(delayMs: number): Promise<void>;
export declare function isPromiseLike<T>(input: T | unknown): input is T extends PromiseLike<infer ValueType> ? PromiseLike<ValueType> : PromiseLike<unknown>;
export declare class PromiseTimeoutError extends Error {
    readonly durationMs: number;
    readonly message: string;
    readonly name = "PromiseTimeoutError";
    constructor(durationMs: number, message?: string);
}
export declare function wrapPromiseInTimeout<PromiseValueType>(durationMs: number, originalPromise: PromiseLike<PromiseValueType>): Promise<PromiseValueType>;
/** A promise which can be resolved or rejected by external code. */
export type DeferredPromiseWrapper<T> = {
    promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
};
export declare function createDeferredPromiseWrapper<T = void>(): DeferredPromiseWrapper<T>;
export type WaitForConditionInputs = {
    conditionCallback: () => boolean | Promise<boolean>;
    timeoutMs?: number;
    intervalMs?: number;
    timeoutMessage?: string;
};
export declare function waitForCondition({ conditionCallback, timeoutMs, intervalMs, timeoutMessage, }: WaitForConditionInputs): Promise<void>;
//# sourceMappingURL=promise.d.ts.map