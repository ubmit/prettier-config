import { extractErrorMessage } from './error';
import { isTruthy } from './function';
export function getEnumTypedKeys(input) {
    // enum keys are always strings
    return getObjectTypedKeys(input).filter((key) => isNaN(Number(key)));
}
export function getEnumTypedValues(input) {
    const keys = getEnumTypedKeys(input);
    return keys.map((key) => input[key]);
}
export function isEnumValue(input, checkEnum) {
    return getEnumTypedValues(checkEnum).includes(input);
}
export function isKeyof(key, object) {
    return typedHasProperty(object, key);
}
export function filterToEnumValues(inputs, checkEnum, caseInsensitive = false) {
    if (caseInsensitive) {
        return inputs.reduce((accum, currentInput) => {
            const matchedEnumValue = getEnumTypedValues(checkEnum).find((actualEnumValue) => {
                return String(actualEnumValue).toUpperCase() === String(currentInput).toUpperCase();
            });
            if (matchedEnumValue) {
                return accum.concat(matchedEnumValue);
            }
            else {
                return accum;
            }
        }, []);
    }
    else {
        return inputs.filter((input) => isEnumValue(input, checkEnum));
    }
}
export function getObjectTypedKeys(input) {
    let reflectKeys;
    try {
        reflectKeys = Reflect.ownKeys(input);
    }
    catch (error) { }
    return (reflectKeys !== null && reflectKeys !== void 0 ? reflectKeys : [
        ...Object.keys(input),
        ...Object.getOwnPropertySymbols(input),
    ]);
}
export function getObjectTypedValues(input) {
    return getObjectTypedKeys(input).map((key) => input[key]);
}
const hasPropertyAttempts = [
    (object, key) => {
        return key in object;
    },
    (object, key) => {
        /** This handles cases where the input object can't use `in` directly, like string literals */
        return key in object.constructor.prototype;
    },
];
export function typedHasProperty(inputObject, inputKey) {
    if (!inputObject) {
        return false;
    }
    return hasPropertyAttempts.some((attemptCallback) => {
        try {
            return attemptCallback(inputObject, inputKey);
        }
        catch (error) {
            return false;
        }
    });
}
export function typedHasProperties(inputObject, inputKeys) {
    return inputObject && inputKeys.every((key) => typedHasProperty(inputObject, key));
}
export function isObject(input) {
    return !!input && typeof input === 'object';
}
export function getEntriesSortedByKey(input) {
    return Object.entries(input).sort((tupleA, tupleB) => tupleA[0].localeCompare(tupleB[0]));
}
export function areJsonEqual(a, b) {
    try {
        const sortedAEntries = getEntriesSortedByKey(a);
        const sortedBEntries = getEntriesSortedByKey(b);
        return JSON.stringify(sortedAEntries) === JSON.stringify(sortedBEntries);
    }
    catch (error) {
        console.error(`Failed to compare objects using JSON.stringify`);
        throw error;
    }
}
/**
 * Creates a new object with the same properties as the input object, but with values set to the
 * result of mapCallback for each property.
 */
export function mapObjectValues(inputObject, mapCallback) {
    let gotAPromise = false;
    const mappedObject = getObjectTypedKeys(inputObject).reduce((accum, currentKey) => {
        const mappedValue = mapCallback(currentKey, inputObject[currentKey], inputObject);
        if (mappedValue instanceof Promise) {
            gotAPromise = true;
        }
        return {
            ...accum,
            [currentKey]: mappedValue,
        };
    }, {});
    if (gotAPromise) {
        return new Promise(async (resolve, reject) => {
            try {
                await Promise.all(getObjectTypedKeys(mappedObject).map(async (key) => {
                    const value = await mappedObject[key];
                    mappedObject[key] = value;
                }));
                resolve(mappedObject);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    else {
        return mappedObject;
    }
}
export function filterObject(inputObject, callback) {
    const filteredKeys = getObjectTypedKeys(inputObject).filter((key) => {
        const value = inputObject[key];
        return callback(key, value, inputObject);
    });
    return filteredKeys.reduce((accum, key) => {
        accum[key] = inputObject[key];
        return accum;
    }, {});
}
/** The input here must be serializable otherwise JSON parsing errors will be thrown */
export function copyThroughJson(input) {
    try {
        return JSON.parse(JSON.stringify(input));
    }
    catch (error) {
        console.error(`Failed to JSON copy for`, input);
        throw error;
    }
}
/**
 * Checks that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export function matchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, shouldLogWhy = false) {
    try {
        assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps);
        return true;
    }
    catch (error) {
        if (shouldLogWhy) {
            console.error(error);
        }
        return false;
    }
}
/**
 * Asserts that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export function assertMatchesObjectShape(testThisOne, compareToThisOne, allowExtraProps = false, noCheckInnerValueOfTheseKeys = {}) {
    const testKeys = getObjectTypedKeys(testThisOne);
    const matchKeys = new Set(getObjectTypedKeys(compareToThisOne));
    if (!allowExtraProps) {
        const extraKeys = testKeys.filter((testKey) => !matchKeys.has(testKey));
        if (extraKeys.length) {
            throw new Error(`Test object has extra keys: ${extraKeys.join(', ')}`);
        }
    }
    matchKeys.forEach((key) => {
        var _a;
        if (!typedHasProperty(testThisOne, key)) {
            throw new Error(`test object does not have key "${String(key)}" from expected shape.`);
        }
        function throwKeyError(reason) {
            throw new Error(`test object value at key "${String(key)}" did not match expected shape: ${reason}`);
        }
        const testValue = testThisOne[key];
        const shouldMatch = compareToThisOne[key];
        if (!noCheckInnerValueOfTheseKeys[key]) {
            compareInnerValue(testValue, shouldMatch, throwKeyError, allowExtraProps, (_a = noCheckInnerValueOfTheseKeys[key]) !== null && _a !== void 0 ? _a : {});
        }
    });
}
function compareInnerValue(testValue, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys) {
    var _a;
    const testType = typeof testValue;
    const shouldMatchType = typeof matchValue;
    if (testType !== shouldMatchType) {
        throwKeyError(`type "${testType}" did not match expected type "${shouldMatchType}"`);
    }
    try {
        if (typedHasProperty(matchValue, 'constructor')) {
            if (!typedHasProperty(testValue, 'constructor') ||
                testValue.constructor !== matchValue.constructor) {
                throwKeyError(`constructor "${(_a = testValue === null || testValue === void 0 ? void 0 : testValue.constructor) === null || _a === void 0 ? void 0 : _a.name}" did not match expected constructor "${matchValue.constructor}"`);
            }
        }
    }
    catch (error) {
        // ignore errors from trying to find the constructor
        if (error instanceof throwKeyError) {
            throw error;
        }
    }
    if (Array.isArray(matchValue)) {
        if (!Array.isArray(testValue)) {
            throwKeyError(`expected an array`);
        }
        testValue.forEach((testValueEntry, index) => {
            const errors = matchValue
                .map((matchValue) => {
                try {
                    compareInnerValue(testValueEntry, matchValue, throwKeyError, allowExtraProps, noCheckInnerValueOfTheseKeys);
                    return undefined;
                }
                catch (error) {
                    return new Error(`entry at index "${index}" did not match expected shape: ${extractErrorMessage(error)}`);
                }
            })
                .filter(isTruthy);
            if (errors.length === matchValue.length) {
                throw new Error(`entry at index "${index}" did not match any of the possible types from "${matchValue.join(', ')}"`);
            }
        });
    }
    else if (isObject(matchValue)) {
        assertMatchesObjectShape(testValue, matchValue, allowExtraProps, noCheckInnerValueOfTheseKeys);
    }
}
export function typedObjectFromEntries(entries) {
    return Object.fromEntries(entries);
}
