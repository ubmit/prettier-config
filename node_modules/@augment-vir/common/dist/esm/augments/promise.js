import { extractErrorMessage } from './error';
import { typedHasProperty } from './object';
export function wait(delayMs) {
    const deferredPromiseWrapper = createDeferredPromiseWrapper();
    if (delayMs === Infinity || delayMs < 0) {
        return deferredPromiseWrapper.promise;
    }
    setTimeout(() => {
        deferredPromiseWrapper.resolve();
    }, delayMs);
    return deferredPromiseWrapper.promise;
}
export function isPromiseLike(input) {
    if (typedHasProperty(input, 'then') && typeof input.then === 'function') {
        return true;
    }
    else {
        return false;
    }
}
export class PromiseTimeoutError extends Error {
    constructor(durationMs, message = `Promised timed out after ${durationMs} ms.`) {
        super(message);
        this.durationMs = durationMs;
        this.message = message;
        this.name = 'PromiseTimeoutError';
    }
}
export function wrapPromiseInTimeout(durationMs, originalPromise) {
    return new Promise(async (resolve, reject) => {
        const timeoutId = setTimeout(() => {
            reject(new PromiseTimeoutError(durationMs));
        }, durationMs);
        try {
            const result = await originalPromise;
            resolve(result);
        }
        catch (error) {
            reject(error);
        }
        finally {
            clearTimeout(timeoutId);
        }
    });
}
export function createDeferredPromiseWrapper() {
    let resolve;
    let reject;
    const promise = new Promise((resolveCallback, rejectCallback) => {
        resolve = resolveCallback;
        reject = rejectCallback;
    });
    if (!resolve || !reject) {
        throw new Error(`Reject and resolve callbacks were not set by the promise constructor for ${createDeferredPromiseWrapper.name}.`);
    }
    return {
        promise,
        resolve,
        reject,
    };
}
export async function waitForCondition({ conditionCallback, timeoutMs = 10000, intervalMs = 100, timeoutMessage = '', }) {
    let condition = false;
    let lastError;
    async function checkCondition() {
        try {
            condition = !!(await conditionCallback());
        }
        catch (error) {
            condition = false;
            lastError = error;
        }
    }
    const startTime = Date.now();
    await checkCondition();
    while (!condition) {
        await wait(intervalMs);
        if (Date.now() - startTime >= timeoutMs) {
            const message = timeoutMessage ? `${timeoutMessage}: ` : '';
            throw new Error(`${message}Timeout of "${timeoutMs}" exceeded waiting for condition to be true${extractErrorMessage(lastError)}`);
        }
        await checkCondition();
    }
}
