"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awaitedFilter = exports.awaitedBlockingMap = exports.awaitedForEach = void 0;
/**
 * Acts like calling Array.prototype.forEach in that all elements are executed upon in order, and
 * each execution is blocking. Meaning, the callback won't be called on element 2 until the callback
 * has finished its call on element 1.
 */
async function awaitedForEach(input, callback) {
    await awaitedBlockingMap(input, callback);
}
exports.awaitedForEach = awaitedForEach;
async function awaitedBlockingMap(input, callback) {
    const mappedValues = await input.reduce(async (accumPromise, currentElement, index, wholeArray) => {
        const accum = await accumPromise;
        const mappedValue = await callback(currentElement, index, wholeArray);
        accum.push(mappedValue);
        return accum;
    }, Promise.resolve([]));
    return mappedValues;
}
exports.awaitedBlockingMap = awaitedBlockingMap;
async function awaitedFilter(arrayInput, filterCallback, options) {
    const callbackResults = (options === null || options === void 0 ? void 0 : options.blocking)
        ? await awaitedBlockingMap(arrayInput, filterCallback)
        : await Promise.all(arrayInput.map(filterCallback));
    return arrayInput.filter((originalValue, index) => !!callbackResults[index]);
}
exports.awaitedFilter = awaitedFilter;
