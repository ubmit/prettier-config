import { AtLeastOneEntryArray } from './array';
import { NoInfer, RequiredBy, UnPromise } from './type';
export declare function getEnumTypedKeys<T extends object>(input: T): (keyof T)[];
export declare function getEnumTypedValues<T extends object>(input: T): T[keyof T][];
export declare function isEnumValue<T extends object>(input: unknown, checkEnum: T): input is T[keyof T];
export declare function isKeyof<ObjectGeneric>(key: PropertyKey, object: ObjectGeneric): key is keyof object;
export declare function filterToEnumValues<T extends object>(inputs: ReadonlyArray<unknown>, checkEnum: T, caseInsensitive?: boolean): T[keyof T][];
export declare function getObjectTypedKeys<ObjectGeneric extends unknown>(input: ObjectGeneric): Array<keyof ObjectGeneric>;
export declare function getObjectTypedValues<ObjectGeneric extends unknown>(input: ObjectGeneric): ObjectGeneric[keyof ObjectGeneric][];
type ExtractValue<KeyGeneric extends PropertyKey, ParentGeneric> = KeyGeneric extends keyof ParentGeneric ? RequiredBy<ParentGeneric, KeyGeneric>[KeyGeneric] : KeyGeneric extends keyof Extract<ParentGeneric, Record<KeyGeneric, any>> ? RequiredBy<Extract<ParentGeneric, Record<KeyGeneric, any>>, KeyGeneric>[KeyGeneric] : never;
type CombinedParentValue<KeyGeneric extends PropertyKey, ParentGeneric> = ExtractValue<KeyGeneric, ParentGeneric> extends never ? unknown : ExtractValue<KeyGeneric, ParentGeneric>;
type CombineTypeWithKey<KeyGeneric extends PropertyKey, ParentGeneric> = ParentGeneric & Record<KeyGeneric, CombinedParentValue<KeyGeneric, ParentGeneric>>;
export declare function typedHasProperty<KeyGeneric extends PropertyKey, ParentGeneric>(inputObject: ParentGeneric, inputKey: KeyGeneric): inputObject is CombineTypeWithKey<KeyGeneric, ParentGeneric>;
export declare function typedHasProperties<KeyGeneric extends PropertyKey, ParentGeneric>(inputObject: ParentGeneric, inputKeys: ReadonlyArray<KeyGeneric>): inputObject is CombineTypeWithKey<KeyGeneric, ParentGeneric>;
export declare function isObject(input: any): input is NonNullable<object>;
export declare function getEntriesSortedByKey(input: object): [string, unknown][];
export declare function areJsonEqual(a: object, b: object): boolean;
export type InnerMappedValues<EntireInputGeneric extends object, MappedValueGeneric> = {
    [MappedProp in keyof EntireInputGeneric]: MappedValueGeneric;
};
export type MappedValues<EntireInputGeneric extends object, MappedValueGeneric> = MappedValueGeneric extends PromiseLike<unknown> ? Promise<InnerMappedValues<EntireInputGeneric, UnPromise<MappedValueGeneric>>> : InnerMappedValues<EntireInputGeneric, UnPromise<MappedValueGeneric>>;
/**
 * Creates a new object with the same properties as the input object, but with values set to the
 * result of mapCallback for each property.
 */
export declare function mapObjectValues<EntireInputGeneric extends object, MappedValueGeneric>(inputObject: EntireInputGeneric, mapCallback: (inputKey: keyof EntireInputGeneric, keyValue: EntireInputGeneric[typeof inputKey], fullObject: EntireInputGeneric) => MappedValueGeneric): MappedValues<EntireInputGeneric, MappedValueGeneric>;
export declare function filterObject<ObjectGeneric extends object>(inputObject: ObjectGeneric, callback: (key: keyof ObjectGeneric, value: ObjectValueType<ObjectGeneric>, fullObject: ObjectGeneric) => boolean): Partial<ObjectGeneric>;
/** The input here must be serializable otherwise JSON parsing errors will be thrown */
export declare function copyThroughJson<T>(input: T): T;
export type ObjectValueType<T extends object> = T[keyof T];
/**
 * Checks that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export declare function matchesObjectShape<MatchThisGeneric extends object>(testThisOne: unknown, compareToThisOne: NoInfer<ObjectWithAtLeastSingleEntryArrays<MatchThisGeneric>>, allowExtraProps?: boolean, shouldLogWhy?: boolean): testThisOne is MatchThisGeneric;
export type ObjectWithAtLeastSingleEntryArrays<BaseObject extends object> = {
    [Prop in keyof BaseObject]: BaseObject[Prop] extends ReadonlyArray<any> ? AtLeastOneEntryArray<BaseObject[Prop]> : BaseObject[Prop] extends object ? ObjectWithAtLeastSingleEntryArrays<BaseObject[Prop]> : BaseObject[Prop];
};
export type NestedBoolean<MatchObject extends object> = Partial<{
    [Prop in keyof MatchObject]: MatchObject[Prop] extends object ? NestedBoolean<MatchObject[Prop]> | boolean : boolean;
}>;
/**
 * Asserts that the first input, testThisOne, matches the object shape of the second input,
 * compareToThisOne. Does not compare exact values of properties, only types.
 *
 * To allow the test input, the first input, to have additional keys that the compare input, the
 * second input, does not have, pass in a third argument set to true.
 *
 * This function REQUIRES a generic to be assigned to it: it cannot infer it from the inputs.
 *
 * The compare input, the second input, is required to have at least one entry in every array value
 * that exists. If more array values are present, they will be considered other possible types for
 * entries in that array.
 */
export declare function assertMatchesObjectShape<MatchThisGeneric extends object = never>(testThisOne: unknown, compareToThisOne: NoInfer<ObjectWithAtLeastSingleEntryArrays<MatchThisGeneric>>, allowExtraProps?: boolean, noCheckInnerValueOfTheseKeys?: NestedBoolean<typeof compareToThisOne>): asserts testThisOne is MatchThisGeneric;
export declare function typedObjectFromEntries<KeyType extends PropertyKey, ValueType>(entries: ReadonlyArray<Readonly<[KeyType, ValueType]>>): Record<KeyType, ValueType>;
export {};
//# sourceMappingURL=object.d.ts.map