"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertLinesIntoArguments = void 0;
const prettier_1 = require("prettier");
const doc_1 = require("../augments/doc");
const child_docs_1 = require("./child-docs");
const nestingSyntaxOpen = '[{(`';
const nestingSyntaxClose = ']})`';
const found = 'Found "(" but';
function insertLinesIntoArguments(inputDoc, forceWrap, lineCounts, wrapThreshold, includesTrailingComma, debug) {
    (0, child_docs_1.walkDoc)(inputDoc, debug, (currentDoc, parentDocs, childIndex) => {
        const currentParent = parentDocs[0];
        const parentDoc = currentParent?.parent;
        if (typeof currentDoc === 'string' && currentDoc.trim() === '(') {
            const undoMutations = [];
            let arrayChildCount = 0;
            if (!Array.isArray(parentDoc)) {
                if (debug) {
                    console.error({ brokenParent: parentDoc, currentDoc });
                }
                throw new Error(`${found} parentDoc is not an array.`);
            }
            if (debug) {
                console.info({ currentDoc, parentDoc });
                console.info(JSON.stringify((0, doc_1.stringifyDoc)(parentDoc, true), null, 4));
            }
            if (childIndex == undefined) {
                throw new Error(`${found} childIndex is undefined`);
            }
            const openingSiblingIndex = childIndex + 1;
            // sibling to the '('
            const openingSibling = parentDoc[openingSiblingIndex];
            let findingSiblingChildren;
            let codePath = '';
            if ((0, doc_1.isDocCommand)(openingSibling)) {
                // case 1. sibling is indent
                if ((0, doc_1.isDocCommand)(openingSibling) && openingSibling.type === 'indent') {
                    findingSiblingChildren = openingSibling.contents;
                    codePath = 'indent';
                }
                // case 2. sibling is concat
                else if ((0, doc_1.isDocCommand)(openingSibling) && openingSibling.type === 'concat') {
                    findingSiblingChildren = openingSibling.parts;
                    codePath = 'concat';
                }
                // case 3. sibling is group
                else if (openingSibling.type === 'group') {
                    const originalBreakValue = openingSibling.break;
                    openingSibling.break = true;
                    undoMutations.push(() => {
                        openingSibling.break = originalBreakValue;
                    });
                    findingSiblingChildren = openingSibling.contents;
                    codePath = 'group';
                }
                else {
                    throw new Error(`${found} and sibling was doc command but didn't match expected types.`);
                }
            }
            // case 4. sibling is an array
            else if (Array.isArray(openingSibling)) {
                findingSiblingChildren = openingSibling;
                codePath = 'array';
            }
            else if (openingSibling === '' && parentDoc[openingSiblingIndex + 1] === ')') {
                // this is for just an empty call, like the parentheses here: () => {}
                return false;
            }
            else {
                throw new Error(`${found} its sibling was not of an expected type`);
            }
            if (!Array.isArray(findingSiblingChildren)) {
                throw new Error(`${found} its sibling's children were not in an array.`);
            }
            const foundSiblingChildren = findingSiblingChildren;
            foundSiblingChildren.forEach((child, index) => {
                if ((0, doc_1.isDocCommand)(child) && child.type === 'line') {
                    foundSiblingChildren[index] = prettier_1.doc.builders.hardlineWithoutBreakParent;
                    undoMutations.push(() => {
                        foundSiblingChildren[index] = child;
                    });
                }
                else if (child &&
                    typeof child === 'string' &&
                    child !== ',' &&
                    !nestingSyntaxClose.includes(child)) {
                    arrayChildCount++;
                }
                else if (Array.isArray(child)) {
                    arrayChildCount++;
                }
            });
            foundSiblingChildren.splice(0, 0, prettier_1.doc.builders.breakParent);
            undoMutations.push(() => {
                foundSiblingChildren.splice(0, 1);
            });
            if (arrayChildCount <= wrapThreshold && !lineCounts.length && !forceWrap) {
                undoMutations.reverse().forEach((undoMutation) => {
                    undoMutation();
                });
            }
            else {
                // foundSiblingChildren.push(',', doc.builders.hardline);
                // parentDoc.forEach((docEntry, index) => {
                //     if (isDocCommand(docEntry)) {
                //         if (docEntry.type === 'line') {
                //             parentDoc[index] = doc.builders.hardlineWithoutBreakParent;
                //         } else if (docEntry.type === 'if-break') {
                //             parentDoc[index] = docEntry.breakContents;
                //         }
                //     }
                // });
                // parentDoc.splice(openingSiblingIndex, 0, doc.builders.hardlineWithoutBreakParent);
                // parentDoc.splice(
                //     0,
                //     0,
                //     doc.builders.breakParent,
                //     doc.builders.hardlineWithoutBreakParent,
                // );
                // const grandparentDoc = parentDocs[1]?.parent;
                // if (!grandparentDoc || typeof grandparentDoc === 'string') {
                //     throw new Error(
                //         `Invalid grandparentDoc value, these could not have had children.`,
                //     );
                // }
                // walkDoc(grandparentDoc, debug, (grandparentInnerDoc) => {
                //     if (Array.isArray(grandparentInnerDoc)) {
                //         grandparentInnerDoc.splice(0, 0, doc.builders.breakParent);
                //         return false;
                //     }
                //     return true;
                // });
            }
            // console.log({codePath, siblingChildren: findingSiblingChildren});
            // don't walk any deeper
            return false;
        }
        else if (debug) {
            console.info({ ignoring: currentDoc });
        }
        return true;
    });
    return inputDoc;
}
exports.insertLinesIntoArguments = insertLinesIntoArguments;
