"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printWithMultilineArrays = void 0;
const common_1 = require("@augment-vir/common");
const prettier_1 = require("prettier");
const doc_1 = require("../augments/doc");
const child_docs_1 = require("./child-docs");
const comment_triggers_1 = require("./comment-triggers");
const insert_new_lines_into_arguments_1 = require("./insert-new-lines-into-arguments");
const supported_node_types_1 = require("./supported-node-types");
const trailing_comma_1 = require("./trailing-comma");
const nestingSyntaxOpen = '[{(`';
const nestingSyntaxClose = ']})`';
const found = 'Found "[" but:';
function insertLinesIntoArray(inputDoc, forceWrap, lineCounts, wrapThreshold, debug) {
    (0, child_docs_1.walkDoc)(inputDoc, debug, (currentDoc, parentDocs, childIndex) => {
        const currentParent = parentDocs[0];
        const parentDoc = currentParent?.parent;
        if (typeof currentDoc === 'string' && currentDoc.trim() === '[') {
            const undoMutations = [];
            let finalLineBreakExists = false;
            function undoAllMutations() {
                undoMutations.reverse().forEach((undoMutation) => {
                    undoMutation();
                });
            }
            if (!Array.isArray(parentDoc)) {
                if (debug) {
                    console.error({ brokenParent: parentDoc, currentDoc });
                }
                throw new Error(`${found} parentDoc is not an array.`);
            }
            if (debug) {
                console.info({ currentDoc, parentDoc });
                console.info(JSON.stringify((0, doc_1.stringifyDoc)(parentDoc, true), null, 4));
            }
            if (childIndex !== 0) {
                throw new Error(`${found} not at index 0 in its parent`);
            }
            const maybeBreak = parentDoc[childIndex + 2];
            if ((0, doc_1.isDocCommand)(maybeBreak) && maybeBreak.type === 'if-break') {
                undoMutations.push(() => {
                    parentDoc[childIndex + 2] = maybeBreak;
                });
                parentDoc[childIndex + 2] = maybeBreak.breakContents;
            }
            const indentIndex = childIndex + 1;
            const bracketSibling = parentDoc[indentIndex];
            if (debug) {
                console.info({ bracketSibling });
            }
            if (bracketSibling === ']') {
                return false;
            }
            if (!(0, doc_1.isDocCommand)(bracketSibling) || bracketSibling.type !== 'indent') {
                throw new Error(`${found} its sibling was not an indent Doc.: ${bracketSibling}`);
            }
            const indentContents = bracketSibling.contents;
            if (debug) {
                console.info({ indentContents });
            }
            if (!Array.isArray(indentContents)) {
                throw new Error(`${found} indent didn't have array contents.`);
            }
            if (indentContents.length < 2) {
                if (debug) {
                    console.error(JSON.stringify((0, doc_1.stringifyDoc)(indentContents, true), null, 4));
                }
                throw new Error(`${found} indent contents did not have at least 2 children`);
            }
            const startingLine = indentContents[0];
            if (debug) {
                console.info({ firstIndentContentsChild: startingLine });
            }
            if (!(0, doc_1.isDocCommand)(startingLine) || startingLine.type !== 'line') {
                if ((0, doc_1.isDocCommand)(startingLine) && startingLine.type === 'concat') {
                    undoAllMutations();
                    return false;
                }
                else {
                    throw new Error(`${found} first indent child was not a line.`);
                }
            }
            indentContents[0] = '';
            undoMutations.push(() => {
                indentContents[0] = startingLine;
            });
            const indentedContent = indentContents[1];
            if (debug) {
                console.info({
                    secondIndentContentsChild: indentedContent,
                    itsFirstChild: indentedContent[0],
                });
            }
            if (!indentedContent) {
                console.error('second indent child (indentedContent) is not defined:', {
                    indentContents,
                    indentedContent,
                });
                throw new Error(`${found} second indent child is not a fill.`);
            }
            if (!Array.isArray(indentedContent) &&
                !((0, doc_1.isDocCommand)(indentedContent) && indentedContent.type === 'fill')) {
                console.error('second indent child (indentCode) is not a fill doc or an array:', {
                    indentContents,
                    indentCode: indentedContent,
                });
                throw new Error(`${found} second indent child is not a fill doc or an array.`);
            }
            if (Array.isArray(indentedContent)
                ? indentedContent.length === 0
                : indentedContent.parts.length === 0) {
                throw new Error(`${found} indentedContent has no length.`);
            }
            // lineIndex is 0 indexed
            let lineIndex = 0;
            // columnCount is 1 indexed
            let columnCount = 1;
            if (debug) {
                console.info(`>>>>>>>>>>>>>> Walking children for commas`);
            }
            let arrayChildCount = 0;
            let forceFinalLineBreakExists = false;
            if (!finalLineBreakExists) {
                (0, child_docs_1.walkDoc)(indentedContent, debug, (currentDoc, commaParents, commaChildIndex) => {
                    finalLineBreakExists = false;
                    const innerCurrentParent = commaParents[0];
                    const innerCurrentParentDoc = innerCurrentParent?.parent;
                    if ((0, doc_1.isDocCommand)(currentDoc) && currentDoc.type === 'if-break') {
                        if (debug) {
                            console.info(`found final line break inside of if-break`);
                        }
                        finalLineBreakExists = true;
                        if (!innerCurrentParentDoc) {
                            throw new Error(`Found if-break without a parent`);
                        }
                        if (!Array.isArray(innerCurrentParentDoc)) {
                            throw new Error(`if-break parent is not an array`);
                        }
                        if (commaChildIndex == undefined) {
                            throw new Error(`if-break child index is undefined`);
                        }
                        innerCurrentParentDoc[commaChildIndex] = currentDoc.breakContents;
                        innerCurrentParentDoc.splice(commaChildIndex + 1, 0, prettier_1.doc.builders.breakParent);
                        undoMutations.push(() => {
                            innerCurrentParentDoc.splice(commaChildIndex + 1, 1);
                            innerCurrentParentDoc[commaChildIndex] = currentDoc;
                        });
                    }
                    else if (typeof currentDoc === 'string') {
                        if (!innerCurrentParentDoc) {
                            console.error({ innerParentDoc: innerCurrentParentDoc });
                            throw new Error(`Found string but innerParentDoc is not defined.`);
                        }
                        if (currentDoc && nestingSyntaxOpen.includes(currentDoc)) {
                            if (!Array.isArray(innerCurrentParentDoc)) {
                                throw new Error(`Found opening syntax but parent is not an array.`);
                            }
                            const closingIndex = innerCurrentParentDoc.findIndex((sibling) => typeof sibling === 'string' &&
                                sibling &&
                                nestingSyntaxClose.includes(sibling));
                            if (closingIndex < 0) {
                                throw new Error(`Could not find closing match for ${currentDoc}`);
                            }
                            // check that there's a line break before the ending of the array
                            if (innerCurrentParentDoc[closingIndex] !== ']') {
                                const closingSibling = innerCurrentParentDoc[closingIndex - 1];
                                if (debug) {
                                    console.info({ closingIndex, closingSibling });
                                }
                                if (closingSibling) {
                                    if (typeof closingSibling === 'object' &&
                                        !Array.isArray(closingSibling) &&
                                        closingSibling.type === 'line') {
                                        if (debug) {
                                            console.info(`found final line break inside of closing sibling`);
                                        }
                                        finalLineBreakExists = true;
                                    }
                                }
                            }
                            return false;
                        }
                        else if (currentDoc && nestingSyntaxClose.includes(currentDoc)) {
                            throw new Error(`Found closing syntax which shouldn't be walked`);
                        }
                        else if (currentDoc === ',') {
                            if (debug) {
                                console.info({ foundCommaIn: innerCurrentParentDoc });
                            }
                            if (!Array.isArray(innerCurrentParentDoc)) {
                                console.error({ innerParentDoc: innerCurrentParentDoc });
                                throw new Error(`Found comma but innerParentDoc is not an array.`);
                            }
                            if (commaChildIndex == undefined) {
                                throw new Error(`Found comma but childIndex is undefined.`);
                            }
                            let siblingIndex = commaChildIndex + 1;
                            let parentToMutate = innerCurrentParentDoc;
                            if (commaChildIndex === innerCurrentParentDoc.length - 1) {
                                const commaGrandParent = commaParents[1];
                                if (commaGrandParent == undefined) {
                                    throw new Error(`Could not find grandparent of comma group.`);
                                }
                                if (commaGrandParent.childIndexInThisParent == undefined) {
                                    throw new Error(`Could not find index of comma group parent`);
                                }
                                if (!Array.isArray(commaGrandParent.parent)) {
                                    throw new Error(`Comma group grandparent is not an array.`);
                                }
                                siblingIndex = commaGrandParent.childIndexInThisParent + 1;
                                parentToMutate = commaGrandParent.parent;
                            }
                            if (debug) {
                                console.info({
                                    commaParentDoc: innerCurrentParentDoc,
                                    parentToMutate,
                                    siblingIndex,
                                });
                            }
                            let maybeCommaSibling = parentToMutate[siblingIndex];
                            while ((!(0, doc_1.isDocCommand)(maybeCommaSibling) ||
                                maybeCommaSibling.type !== 'line') &&
                                siblingIndex < parentToMutate.length) {
                                if (debug) {
                                    console.info(`Trying to find comma sibling at index ${siblingIndex}`);
                                }
                                siblingIndex++;
                                maybeCommaSibling = parentToMutate[siblingIndex];
                            }
                            if (!(0, doc_1.isDocCommand)(maybeCommaSibling) ||
                                maybeCommaSibling.type !== 'line') {
                                throw new Error(`Found comma but its following sibling is not a line: ${maybeCommaSibling}`);
                            }
                            const commaSibling = maybeCommaSibling;
                            const currentLineCountIndex = lineIndex % lineCounts.length;
                            const currentLineCount = lineCounts.length
                                ? lineCounts[currentLineCountIndex]
                                : undefined;
                            arrayChildCount++;
                            if ((currentLineCount && columnCount === currentLineCount) ||
                                !currentLineCount) {
                                // if we're on the last element of the line then increment to the next line
                                lineIndex++;
                                columnCount = 1;
                                /**
                                 * Don't use doc.builders.hardline here. It causes "invalid size
                                 * error" which I don't understand and which has no other useful
                                 * information or stack trace.
                                 */
                                if (debug) {
                                    console.info({
                                        breakingAfter: parentToMutate[siblingIndex - 1],
                                    });
                                }
                                parentToMutate[siblingIndex] =
                                    prettier_1.doc.builders.hardlineWithoutBreakParent;
                            }
                            else {
                                parentToMutate[siblingIndex] = ' ';
                                columnCount++;
                            }
                            undoMutations.push(() => {
                                parentToMutate[siblingIndex] = commaSibling;
                            });
                        }
                    }
                    else if ((0, doc_1.isDocCommand)(currentDoc) && currentDoc.type === 'concat') {
                        const firstPart = currentDoc.parts[0];
                        const secondPart = currentDoc.parts[1];
                        if (debug) {
                            console.info('got concat child doc');
                            console.info(currentDoc.parts, { firstPart, secondPart });
                            console.log((0, doc_1.isDocCommand)(firstPart), (0, doc_1.isDocCommand)(secondPart), firstPart.type === 'line', firstPart.hard, secondPart.type === 'break-parent');
                        }
                        if ((0, doc_1.isDocCommand)(firstPart) &&
                            (0, doc_1.isDocCommand)(secondPart) &&
                            firstPart.type === 'line' &&
                            firstPart.hard &&
                            secondPart.type === 'break-parent') {
                            if (debug) {
                                console.info('concat child was indeed a line break');
                            }
                            forceFinalLineBreakExists = true;
                            return false;
                        }
                        else if (debug) {
                            console.info('concat child doc was not a line break');
                        }
                    }
                    return true;
                });
            }
            if (forceFinalLineBreakExists) {
                finalLineBreakExists = true;
            }
            if (!finalLineBreakExists) {
                if (debug) {
                    console.info(`Parsed all array children but finalBreakHappened = ${finalLineBreakExists}`);
                }
                const closingBracketIndex = parentDoc.findIndex((openingBracketSibling) => openingBracketSibling === ']');
                parentDoc.splice(closingBracketIndex, 0, prettier_1.doc.builders.hardlineWithoutBreakParent);
                undoMutations.push(() => {
                    parentDoc.splice(closingBracketIndex, 1);
                });
            }
            if (Array.isArray(indentedContent)) {
                const oldIndentContentChild = indentContents[1];
                indentContents.splice(1, 1, prettier_1.doc.builders.group([
                    prettier_1.doc.builders.hardlineWithoutBreakParent,
                    ...indentedContent,
                ]));
                undoMutations.push(() => {
                    indentContents[1] = oldIndentContentChild;
                });
            }
            else {
                const oldParts = indentedContent.parts;
                indentedContent.parts = [
                    prettier_1.doc.builders.group([
                        prettier_1.doc.builders.hardlineWithoutBreakParent,
                        ...indentedContent.parts,
                    ]),
                ];
                undoMutations.push(() => {
                    indentedContent.parts = oldParts;
                });
            }
            if (arrayChildCount < wrapThreshold && !lineCounts.length && !forceWrap) {
                undoAllMutations();
            }
            // don't walk any deeper
            return false;
        }
        else if (debug) {
            console.info({ ignoring: currentDoc });
        }
        return true;
    });
    // return what is input because we perform mutations on it
    return inputDoc;
}
function getLatestSetValue(currentLine, triggers) {
    const relevantSetLineCountsKey = (0, common_1.getObjectTypedKeys)(triggers)
        .sort()
        .reduce((closestKey, currentKey) => {
        if (Number(currentKey) < currentLine) {
            const currentData = triggers[currentKey];
            if (currentData && currentData.lineEnd > currentLine) {
                return currentKey;
            }
        }
        return closestKey;
    }, '');
    const relevantSetLineCount = triggers[relevantSetLineCountsKey]?.data;
    return relevantSetLineCount;
}
function printWithMultilineArrays(originalFormattedOutput, path, inputOptions, debug) {
    const rootNode = path.stack[0];
    if (!rootNode) {
        throw new Error(`Could not find valid root node in ${path.stack.map((entry) => entry.type).join(',')}`);
    }
    const node = path.getValue();
    if (node &&
        ((0, supported_node_types_1.isArrayLikeNode)(node) ||
            (inputOptions.multilineFunctionArguments && (0, supported_node_types_1.isArgumentsLikeNode)(node)))) {
        if (!node.loc) {
            throw new Error(`Could not find location of node ${node.type}`);
        }
        const currentLineNumber = node.loc.start.line;
        const lastLine = currentLineNumber - 1;
        const commentTriggers = (0, comment_triggers_1.getCommentTriggers)(rootNode, debug);
        const originalText = inputOptions.originalText;
        const includesTrailingComma = (0, trailing_comma_1.containsTrailingComma)(node.loc, 'arguments' in node
            ? node.arguments
            : 'params' in node
                ? node.params
                : node.elements, originalText.split('\n'), debug);
        const forceWrap = includesTrailingComma;
        const relevantSetLineCount = getLatestSetValue(currentLineNumber, commentTriggers.setLineCounts);
        const lineCounts = commentTriggers.nextLineCounts[lastLine] ??
            relevantSetLineCount ??
            (0, comment_triggers_1.parseNextLineCounts)(inputOptions.multilineArraysLinePattern, false, debug);
        const relevantSetWrapThreshold = getLatestSetValue(currentLineNumber, commentTriggers.setWrapThresholds);
        const wrapThreshold = commentTriggers.nextWrapThresholds[lastLine] ??
            relevantSetWrapThreshold ??
            inputOptions.multilineArraysWrapThreshold;
        if (debug) {
            if ((0, supported_node_types_1.isArgumentsLikeNode)(node)) {
                console.info(`======= Starting call to ${insert_new_lines_into_arguments_1.insertLinesIntoArguments.name}: =======`);
            }
            else {
                console.info(`======= Starting call to ${insertLinesIntoArray.name}: =======`);
            }
            console.info({ options: { lineCounts, wrapThreshold } });
        }
        const newDoc = (0, supported_node_types_1.isArgumentsLikeNode)(node)
            ? (0, insert_new_lines_into_arguments_1.insertLinesIntoArguments)(originalFormattedOutput, forceWrap, lineCounts, wrapThreshold, includesTrailingComma, debug)
            : insertLinesIntoArray(originalFormattedOutput, forceWrap, lineCounts, wrapThreshold, debug);
        return newDoc;
    }
    return originalFormattedOutput;
}
exports.printWithMultilineArrays = printWithMultilineArrays;
